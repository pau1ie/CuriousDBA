---
title: "SQL Tuning"
date: 2019-10-11T12:00:11+01:00
draft: true
tags: ['DBA','Optimizer','Oracle','Parsing','Performance','SQL','Tuning']
---

# SQL Tuning

As a DBA I find that people think I know about how to tune SQL. They present me with a query that looks simple, but on inspection has
views all the way down, and has an explain plan of over 100 lines. It is difficult to know where to start, particularly when you don't know what the SQL is
supposed to be doing, or understand the structure of the data within the database.

## Talk to the developer

When presented with some slow SQL, the first thing to do is to speak to someone who knows what it is supposed to do, ideally the
person who wrote it or is responsible for maintaining it. It is possible that as they are explaining what it does, you will work out something
that it is doing that it need not. Also as you talk about the way data is selected and how you would expect the optimiser to find the data,
it might become obvious that the optimiser can't do what they expected.


## Explain plans

While discussing the SQL with the developer, it is useful to have the explain plan to hand. Not only the plan generated by an explain plan, but also the 
plan from an actual run of the SQL statement. If you are using SQL Developer, there are tools built in which make gathering the actual
plan easier:
There is the explain plan menu on right click, but there are also a few other menu options as well. One problem when tuning SQLs which
generate large datasets, is that the performace of the tool in displaying the results masks the performance of the database, so if a lot of rows
are selected quickly but then take forever to display, the developer may think their SQL is running slowly when in fact it isn't.


## SQL Developer

SQL Developer is based on Eclipse, and runs in Java. It has a reputation for being bloated and slow. However it does come with a number
of tools to make life easier.

### Explain Plan

This generates an explain plan. The user can see the cardinality and the cost. The optimiser may decide to run a statement differently
than the explain plan would suggest because of features such as bind peeking. Variable data types don't seem to be dealt with very
well in an explain plan, so it can be better to run the SQL and then look at the results. Interesting rows are Cardinality, which is 
an estimate, and cost, which is also an estimate. It can be used to estimate which parts of the query are likely to run slowly. It contains
a section containing a list of hints which should force the use of the plan, though data type conversions may mean that is not possible.
The explain plan can be accessed by using the context menu (right click), or using the icon highlighted below.

![Explain Plan](../../images/SQLTuning/sqldexplain.png)

### Autotrace

Autotrace runs the query, it accepts but does not display the results. This means that the query generates all the load on the database,
but none on the local PC.  This solves the problem of a query appearing to run slow because SQLDeveloper is struggling to display
all the results.

It returns resource usage statistics from the local statistics table, v$mystats which shows the operations that were used by the
session. More interestingly though
the explain plan contains some extra information. `LAST_CR_BUFFER_GETS` and `LAST_ELAPSED_TIME`. These are actual statistics from the last run, so
more reliable than the cost and cardinality in the explain plan. It also contains the hints section like the explain plan.

The autotrace function can also be accessed from the context menu, or an icon next to the explain plan button as highlighted below.

![Autotrace](../../images/SQLTuning/sqldautotrace.png)

### Cursor display

If the SQL has been run (By an autotrace or interactively, the cursor can be displayed. This is similar to the explain plan, but displays the
actual plan from the cursor. This can be selected from the Explain Plan menu, or the explan plan icon drop down menu. Select one
of the lines that starts `V$SQL_PLAN.SQL_ID=`, and isn't greyed out. There are reasons why the same SQL can create different plans, e.g.
bind peeking or cardinality feedback. This is why there is more than one menu entry, though they are rarely populated. See the
screenshot below for an example of the SQL having been run.

![Cursor Display](../../images/SQLTuning/sqldcursormenu.png)


## DBMS_XPLAN

If the cursor has been run, it is possible to display it using dbms_xplan. This is better if plan statistics have been gathered, which can be done
by adding a hint to the SQL `/*+ gather_plan_statistics */` This adds a little extra time to the execution, because it is recording statistics,
but it is worth it, because of the extra detail that can be displayed.

Notice the command to do generate the report is entered into sql developer from the explain plan context menu. It will need to be run
before the output can be viewed. This is particularly useful in working out
where the optimiser went wrong, because it displays the expected rows and the actual rows. The rule of thumb is that if the actual number of
rows is wrong by an order of magnitude, the optimiser is likely to make a wrong decision about the execution plan. DBMS_XPLAN displays the time
taken on each step, so is useful for focussing tuning effort.

To create the SQL to show the plan, select the DBMS_XPLAN entry from the explain plan menu (Under the V$SQL_PLAN.SQL_ID= entries described
above.

![DBMS_XPLAN menu entry](../../images/SQLTuning/sqldcursor.png)

And here is an example of the report displaying expected and actual rows:

![DBMS_XPLAN report](../../images/SQLTuning/sqldxplan.png)


# Tuning and Diagnostic Pack Options

I am not an expert on licensing, so please check what I say before using features which might be cost options.
I believe all the above tools can be used under the Oracle Enterprise Edition license. For those who
have the Tuning and Diagnostic pack, there is another very useful feature as follows:


## Real Time SQL Monitor

From the View menu select `DBA`. The DBA section will appear under Connections and Reports to the left of the screen. Click the green
Plus icon and add an already created connection to the list (or create a new one by pressing the green plus in the windows that appears).
Expand `SID`->`Tuning`->`Real Time SQL Monitor`. This displays the following
screen. Currently running and recently completed SQL is displayed. Click on an SQL to display the plan statistics in the bottom half of the
screen. It might be necessary to enable tuning and diagnostic pack `Tools`->`Prefereces`->`Database`->`Licensing` 
(so long as there is an appropriate license).

![Add DBA functions to SQL Developer](../../images/SQLTuning/sqldaddba.png)

This contains the plan statistics. The timeline shows the parts of the plan that were
running at different times. The number of bytes read can be an indication as to why a query is slow, e.g. if it has to read 2T of data
and then returns 3 rows, there might be a more efficient way to gather the required data!

![Plan Statistics](../../images/SQLTuning/sqlistatus.png)

## Instance Viewer

The instance viewer is also available from the DBA section under Database Status. It draws a pretty screen with some graphs of the general
status of the database. The most interesting part for our purposes is the Top SQL section, which displays the longest running SQL
in descending time order. Right clicking on an SQL gives a context menu from which it is possible to select Details.

The SQL Details screen that appears displays the SQL at the top, and a number of reports in the tabs below it. The explain plan
is pretty much the same as is generated from other options above, and doesn't contain as much information. Bind Variables can be
useful in working out what caused the SQL to run slowly. SQL Tuining Advice runs an adviser, which can give useful advice on how
to tune the SQL, e.g. missing indexes or statistics, expensive operations. Sometimes it generates an SQL profile, which is an execution
plan which the advisor considers is quicker than the one generated by the optimiser. This should not really be accepted by developers, it
is better to work out why the optimiser is generating a bad plan and change the SQL or the stats so it creates a better one. It can be 
useful in production when a query is running slowly and a magic bullet is required!
